log(1e-5)
seq(log(1e-5),log(10),length=10)
load("C:/Users/Xin/OneDrive/bangmang/Data analysis/code/91_y_all_G_10lam_10sig.Rdata")
possible_indx[potential_y_indx]#t
conditions[83]
selected_G_names[[24.]]
selected_G_names[[24]]
method_names1[[24]]
method_names2[[24]]
method_names3[[24]]
length(possible_indx)
load("C:/Users/Xin/OneDrive/bangmang/simulation code/simulation code/comp_s1_fix_sd.Rdata")
lambda
lambdas
mean_result
load("C:/Users/Xin/OneDrive/bangmang/simulation code/plot/complex_ncol5_vsbeta.Rdata")
load("C:/Users/Xin/OneDrive/bangmang/simulation code/simulation code/comp_s1_fix_sd.Rdata")
ibrary(latex2exp)
library(MASS)
yplot_SLR<-sapply(1:151,function(x) {
return(mean_result[1,][[x]])
})
yplot_Kernel<-sapply(1:151,function(x) {
return(mean_result[2,][[x]])
})
yplot_igwas<-sapply(1:151,function(x) {
return(mean_result[4,][[x]])
})
plot(yplot_Kernel~beta1_grid,xlab=(TeX('$\\beta_1$')), ylab='Power',ylim=c(0,1),
type='o',lty=1,col='red',lwd=2.2,yaxt='n',
cex.lab=1.5, cex.axis=1.3, cex.main=1.5, cex.sub=1.5)
#SLR
# points(yplot_SLR~beta1_grid,pch=6,col='blue',lwd=1.85)
lines(yplot_SLR~beta1_grid,lty=1,col='blue',lwd=1.85)
#igwas
# points(yplot_igwas~beta1_grid,pch=5,col=25,lwd=1.5)
lines(yplot_igwas~beta1_grid,lty=1,col=25,lwd=1.5)
abline(a = 0.05, b = 0,lty=2)
axis(side=2, at=c(0,0.05,0.2,0.4,0.6,0.8,1),
labels=c(0,0.05,0.2,0.4,0.6,0.8,1),cex.axis=1.3,las=2)
legend(0.02, 0.3, c("KMM","SLR", "Zhao et al."),
col = c('red', 'blue', 25),
text.col = "black", lty = c(1, 1, 1),lwd=c(2.2,2,1.5),
pch=c(1,NA,NA),
merge = TRUE, bg = "gray90",cex=1.1)
library(latex2exp)
library(MASS)
yplot_SLR<-sapply(1:151,function(x) {
return(mean_result[1,][[x]])
})
yplot_Kernel<-sapply(1:151,function(x) {
return(mean_result[2,][[x]])
})
yplot_igwas<-sapply(1:151,function(x) {
return(mean_result[4,][[x]])
})
plot(yplot_Kernel~beta1_grid,xlab=(TeX('$\\beta_1$')), ylab='Power',ylim=c(0,1),
type='o',lty=1,col='red',lwd=2.2,yaxt='n',
cex.lab=1.5, cex.axis=1.3, cex.main=1.5, cex.sub=1.5)
#SLR
# points(yplot_SLR~beta1_grid,pch=6,col='blue',lwd=1.85)
lines(yplot_SLR~beta1_grid,lty=1,col='blue',lwd=1.85)
#igwas
# points(yplot_igwas~beta1_grid,pch=5,col=25,lwd=1.5)
lines(yplot_igwas~beta1_grid,lty=1,col=25,lwd=1.5)
abline(a = 0.05, b = 0,lty=2)
axis(side=2, at=c(0,0.05,0.2,0.4,0.6,0.8,1),
labels=c(0,0.05,0.2,0.4,0.6,0.8,1),cex.axis=1.3,las=2)
legend(0.02, 0.3, c("KMM","SLR", "Zhao et al."),
col = c('red', 'blue', 25),
text.col = "black", lty = c(1, 1, 1),lwd=c(2.2,2,1.5),
pch=c(1,NA,NA),
merge = TRUE, bg = "gray90",cex=1.1)
22000/12
22000/8
rm(list=ls())
?ls()
?list
?MASS
round(1.1)
round(1.5)
rm(list=ls())
library(MASS)
library(doParallel)
library(foreach)
library(mvtnorm)
library(ContaminatedMixt)
library(foreach)
# library(distrEllipse)
# setwd("C:\\Users\\Xin\\OneDrive\\research\\change point covariance\\code\\simulation")
# setwd('/home/xin/OneDrive/Research/change point covariance/code/simulation')
# setwd("/home/xin/Dropbox/Research/change point covariance/code/simulation")
setwd("C:\\Users\\Xin\\Dropbox\\Research\\change point covariance\\code\\simulation")
source("change_point_bootstrap_lib.R")
# -------------------------------------------
# Simulation setup
# -------------------------------------------
ncores=8
n=100
d=40
nBoot=200
nSim=100
#bandwidth fitting
# b=0.8*n^(-1/5)
b=0.1
Sigma1=diag(rep(1,d))
Sigma2=diag(rep(1,d))
cp_indx=50#the index of the change point
para=list(Sigma1=Sigma1,Sigma2=Sigma2,
df=10)
alpha_hat_arr=array(0,c(nSim,25))
alpha=seq(0.01,0.99,length.out=25)#range of probability
cl <- makeCluster(ncores)
registerDoParallel(cl)
for (nn in 1:nSim){
print(nn)
set.seed(nn)
#data generation
X=bootstrap_gen(n,d,cp_indx,family='t',para=para)
#bootstrap
W=bootstrap_fit(X,nBoot,b,ncores)
W_sort=sort(W)
#Empirical cdf of W
ecdf_W=ecdf(W)
prob_W=ecdf_W(W_sort)#discontinuity points of W's ecdf
prob_W_interval=c(0,prob_W[-length(prob_W)])
#sample quantile (prob 0 represents smallest sample while prob 1 represents largest sample)
# sq=sapply(1:length(alpha),FUN=function(x){
#   W_sort[sum(alpha[x]>prob_W_interval)]
# })
sq=quantile(W,probs=alpha)
T_n=T_statistic(X,b,ncores)
alpha_hat_arr[nn,]=sapply(1:length(sq),FUN=function(x){
T_n<=sq[x]
})
}
stopCluster(cl)
# alpha_hat=as.vector(apply(alpha_hat_arr,MARGIN=2,mean))
alpha_hat=colMeans(alpha_hat_arr)
plot(alpha,alpha_hat,xlab='alpha',ylab='Bootstrap approximation',type='b')
abline(a=0,b=1)
# save.image("change_point_detection.Rdata")
?plot
plot(alpha,alpha_hat,xlab='alpha',ylab='Bootstrap approximation',type='b',xlim=c(0, 1),ylim=c(0,1))
abline(a=0,b=1)
rm(list=ls())
library(MASS)
library(doParallel)
library(foreach)
library(mvtnorm)
library(ContaminatedMixt)
library(foreach)
# library(distrEllipse)
# setwd("C:\\Users\\Xin\\OneDrive\\research\\change point covariance\\code\\simulation")
# setwd('/home/xin/OneDrive/Research/change point covariance/code/simulation')
# setwd("/home/xin/Dropbox/Research/change point covariance/code/simulation")
setwd("C:\\Users\\Xin\\Dropbox\\Research\\change point covariance\\code\\simulation")
source("change_point_bootstrap_lib.R")
# -------------------------------------------
# Simulation setup
# -------------------------------------------
ncores=8
n=100
d=40
nBoot=200
nSim=100
#bandwidth fitting
# b=0.8*n^(-1/5)
b=0.1
Sigma1=diag(rep(1,d))
Sigma2=diag(rep(1,d))
cp_indx=50#the index of the change point
para=list(Sigma1=Sigma1,Sigma2=Sigma2,
df=10)
alpha_hat_arr=array(0,c(nSim,25))
alpha=seq(0.01,0.99,length.out=25)#range of probability
cl <- makeCluster(ncores)
registerDoParallel(cl)
for (nn in 1:nSim){
print(nn)
set.seed(nn)
#data generation
X=bootstrap_gen(n,d,cp_indx,family='t',para=para)
#bootstrap
W=bootstrap_fit(X,nBoot,b,ncores)
W_sort=sort(W)
#Empirical cdf of W
ecdf_W=ecdf(W)
prob_W=ecdf_W(W_sort)#discontinuity points of W's ecdf
prob_W_interval=c(0,prob_W[-length(prob_W)])
#sample quantile (prob 0 represents smallest sample while prob 1 represents largest sample)
sq=sapply(1:length(alpha),FUN=function(x){
W_sort[sum(alpha[x]>prob_W_interval)]
})
# sq=quantile(W,probs=alpha)
T_n=T_statistic(X,b,ncores)
alpha_hat_arr[nn,]=sapply(1:length(sq),FUN=function(x){
T_n<=sq[x]
})
}
stopCluster(cl)
# alpha_hat=as.vector(apply(alpha_hat_arr,MARGIN=2,mean))
alpha_hat=colMeans(alpha_hat_arr)
plot(alpha,alpha_hat,xlab='alpha',ylab='Bootstrap approximation',type='b',xlim=c(0, 1),ylim=c(0,1))
abline(a=0,b=1)
# save.image("change_point_detection.Rdata")
save.image("change_point_detection.Rdata")
